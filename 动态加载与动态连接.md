# 程序调用其他程序的三种方法
只有三种方法。[<sup>[1]</sup>](#refer-anchor)
动态连接，静态连接，动态加载。

![Library hierarchy in Linux](static/LibraryHierarchyinLinux.gif)

Library hierarchy in Linux

# 动态连接
1. 注明你需要用到的库。
2. Linux 在执行时加载共享库（除非库已经在内存中了）
## Linux中的 Dynamic Linking
1. ELF image

启动应用时，会调用ELF IMAGE

2. 内核加载 ELF image 到 虚拟内存中

3. 内核检查虚拟内存中的 .interp 段，.interp 段指向了一个特殊的动态链接器(比如 /lib/ld-linux.so[<sup>*1</sup>](#comment)).他初始化自身，然后做relocation来关联一些 **speicified** shared objects.

这里会涉及到relocation，只修改Global offset table和Procedure Linkage Table。使地址可以正确的被映射到shared library中

4. relocation完成后，dynamic linker就允许任意的加载好的shared object来执行他们的可做可不做的初始化了。

5. 卸载时，会调用elf image的 .fini 段。


## 例子

test.cpp

``` c
#include <filesystem>
int main(){
    std::filesystem::path p = "/bin";
    return 0;
}
```
shell
``` shell
g++ test.cpp -lstdc++fs -std=c++17
```
# 动态加载

动态链接是Linux在做连接这个事情，但是动态加载是由 application 本身来做的。application 本身可以选择一个特定的库来加载，然后直接调用这里面的函数。（当成executable）。


**用来加载的shared library和前面的shared library并无不同，**
## 加载过程
1. 可以在运行时，把库(library)加载到内存中。
2. 检索变量和函数的地址。
3. 执行函数或获取变量
4. 把库从内存中卸载掉

## 调用的API
|function|description|
|-|-|
|dlopen	|Makes an object file accessible to a program
|dlsym	|Obtains the address of a symbol within a dlopen ed object file
|dlerror	|Returns a string error of the last error that occurred
|dlclose	|Closes an object file

<sup>*</sup>具体的内容可以man *.2查看

## 负责动态加载的代码
``` c
#include <stdio.h>
#include <dlfcn.h>
#include <string.h>

#define MAX_STRING      80

void invoke_method( char *lib, char *method, float argument )
{
  void *dl_handle;
  float (*func)(float);
  char *error;

  /* Open the shared object */
  dl_handle = dlopen( lib, RTLD_LAZY );
  if (!dl_handle) {
    printf( "!!! %s\n", dlerror() );
    return;
  }

  /* Resolve the symbol (method) from the object */
  func = dlsym( dl_handle, method );
  error = dlerror();
  if (error != NULL) {
    printf( "!!! %s\n", error );
    return;
  }

  /* Call the resolved method and print the result */
  printf("  %f\n", (*func)(argument) );

  /* Close the object */
  dlclose( dl_handle );

  return;
}

int main( int argc, char *argv[] )
{
  char line[MAX_STRING+1];
  char lib[MAX_STRING+1];
  char method[MAX_STRING+1];
  float argument;

  while (1) {

    printf("> ");

    line[0]=0;
    fgets( line, MAX_STRING, stdin);

    if (!strncmp(line, "bye", 3)) break;

    sscanf( line, "%s %s %f", lib, method, &argument);

    invoke_method( lib, method, argument );

  }

}
```

# Loading 与 Linking 的区别
 **Unlike static linking and dynamic linking。**
 
 Dynamic Loading 允许程序在库没有被指明时被运行起来。去寻找可用的库，然后去尽可能获取附加功能[<sup>[1]</sup>](#refer-anchor)

Instead of Linux automatically loading and linking libraries for a given program, it’s possible to share this control with the application itself. In this case, the process is called dynamic loading.[<sup>[2]</sup>](#refer-anchor)

dynamic linking, which is commonly used - when compiling your executable you must **specify the shared library** your program uses, otherwise it won't even compile. When your program starts it's the system's job to open these libraries, which can be listed using the ldd command.

when your program runs, it's the program's job to open that library. Such programs are usually linked with libdl, which provides the ability to open a shared library.[<sup>[3]</sup>](#refer-anchor)

## 共同点
他们都调用了 ld-linux


# 引用
<div id="refer-anchor">

[1] http://en.volupedia.org/wiki/Dynamic_loading

[2] https://developer.ibm.com/tutorials/l-dynamic-libraries/#dynamic-loading-example

[3] https://stackoverflow.com/questions/10052464/difference-between-dynamic-loading-and-dynamic-linking
</div>


# 注释
<div id="comment">
*1 ld-linux.so 被编译好了，也不依赖其他共享库，他是独立存在的。所以，就是类似于树根一样的共享库的始祖角色。
</div>