# 硬件和软件的桥梁
# CPU Reset
1. minimal.S 最小的程序可以在操作系统上执行的
2. 用 gcc 编译，用ld链接。
```
gcc -c minimal.S
ld minimal.o
gdb a.out
```

 0x0000000000401000  ? mov    $0x1,%rax

 0x0000000000401007  ? mov    $0x1,%rdi

 0x000000000040100e  ? mov    $0x40102e,%rsi

 0x0000000000401015  ? mov    $0x1c,%rdx

 **0x000000000040101c  ? syscall**  # 打印hello world

 0x000000000040101e  ? mov    $0x3c,%rax

 0x0000000000401025  ? mov    $0x1,%rdi

 0x000000000040102c  ? syscall # 运行结束

# 问题
1. 告诉硬件，加载这段代码到计算机
2. 硬件提供一些类似于syscall的功能，（比如访问硬件，操作io等）

# 厂商提供了
==== asset =====

软件设计者和硬件设计者达成约定，就可以了。

## 计算机硬件也是状态机

厂商给cpu一个asset 后的确定的状态
比如:
eip,pc,ds,cs,eax ... 

因此 cpu reset 后，OS 保证 cpu的pc可以读到一个确定的指令就可以。

# processor state after starting up

x86 在启动时还是16bit模式 且中断是关闭的。

qemu 这种模拟器，也是完全的抄手册的。

厂商的代码是一段写死在ROM的代码，这个代码会扫描你的介质。ROM里是一个软件，启动执行。
这个软件老的时候是BIOS，现在是 UEFI。

如何提供 Legacy BIOS，扫描系统硬件，然后找到操作系统， 加载操作系统， 然后使用操作系统。

BIOS 中 0-512 字节是 MBR，主引导扇区，需要cpu把他搬运到内存，然后启动。

## 实验
打印前512字节
```
hexdump -C -n 512 /dev/sda
```

每次开始的时候BIOS，读各个设备的前 512 字节，查看是否是 55aa , 如果是的话，就是引导设备的第一个扇区加载到物理内存的7c00位置

如何看到BIOS的代码？

watchpoint 运行 qemu-system-x86_64

# FIRMWARE 解决了 现有硬件还是先有程序
## 硬件缺陷
intel 430TX 允许写入 FLASH ROM  